# 微服务开发与实践：服务间通信与负载均衡

## 1. 学习目标

本节内容旨在帮助开发者掌握微服务架构中的核心通信机制：

1. 理解同步与异步通信的区别
2. 使用 OpenFeign 实现声明式服务调用
3. 理解负载均衡原理，并使用 Spring Cloud LoadBalancer
4. 掌握基于 Resilience4j 的容错机制（熔断、降级、重试）

## 2. 服务间通信方式

### 2.1 通信模式概览

微服务通信主要分为同步和异步两种模式。

| 特性 | 同步通信 (REST/HTTP, RPC) | 异步通信 (消息队列, 事件流) |
|------|---------------------------|---------------------------|
| 交互方式 | 请求 -> 等待 -> 响应 | 发送消息 -> 继续执行 -> (另一端)消费 |
| 优点 | 实时获取结果，逻辑简单直观 | 解耦，提高吞吐量，削峰填谷 |
| 适用场景 | 用户交互、强依赖、需立即返回结果 | 耗时任务、弱依赖、流量突发 |

### 2.2 协议选择：REST vs RPC

在同步通信中，REST 和 RPC 是两种主流选择。

- **REST (HTTP/JSON)**: 资源导向，通用性强，易于调试，适合公共 API
- **RPC (Protobuf/Thrift)**: 方法导向，性能高（二进制协议），适合内部复杂的高性能调用

## 3. OpenFeign：声明式服务调用

### 3.1 简介与优势

OpenFeign 是一个声明式的 HTTP 客户端，通过注解简化了 HTTP 请求的编写。

对比 RestTemplate: OpenFeign 更简洁、易维护，避免了手动拼接 URL 的繁琐代码。

特性: 集成了 LoadBalancer 和 Resilience4j，支持可插拔编解码器。

### 3.2 快速入门

#### 1. 添加依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

#### 2. 启用 Feign

在启动类上添加注解：

```java
@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication { ... }
```

#### 3. 定义客户端接口

```java
@FeignClient(name = "user-service", path = "/api")
public interface UserClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") Long id);
}
```

#### 4. 业务中使用

直接注入接口即可像调用本地方法一样使用：

```java
@Autowired
private UserClient userClient;

public void createOrder(Order order) {
    User user = userClient.getUser(order.getUserId());
    // ...
}
```

### 3.3 高级配置

- **超时配置**: 可在 YAML 中设置连接和读取超时时间（全局或指定服务）
- **请求拦截器**: 可通过实现 RequestInterceptor 添加通用请求头（如认证 Token）或参数

## 4. 负载均衡 (Load Balancing)

### 4.1 为什么需要负载均衡？

为了解决单点故障和性能瓶颈，实现高可用和水平扩展。

### 4.2 客户端负载均衡 vs 服务端负载均衡

| 类型 | 服务端负载均衡 (如 Nginx) | 客户端负载均衡 (如 Spring Cloud LoadBalancer) |
|------|---------------------------|-----------------------------------------------|
| 特点 | 集中管理，客户端无感知，适合外部流量入口 | 客户端维护服务列表，减少网络跳转，适合微服务内部调用 |

### 4.3 常见策略

- **轮询 (Round Robin)**: 依次分配，简单平均
- **随机 (Random)**: 随机选择
- **加权轮询**: 根据实例性能分配权重
- **最少连接**: 优先选择当前连接数最少的实例

### 4.4 Spring Cloud LoadBalancer 使用

- **依赖**: 添加 spring-cloud-starter-loadbalancer
- **集成**: OpenFeign 会自动集成 LoadBalancer，无需额外代码配置即可实现负载均衡
- **配置**: 可通过 YAML 禁用 Ribbon（旧版）并配置缓存参数

## 5. 容错与 Resilience4j

### 5.1 服务雪崩效应

当某个服务（如服务 C）故障或响应慢时，会导致上游服务（服务 B、A）线程阻塞耗尽，最终导致整个系统不可用。

### 5.2 Resilience4j 核心模块

Resilience4j 是一个轻量级、函数式的容错库，专为 Java 8+ 设计。

- **CircuitBreaker**: 熔断器
- **RateLimiter**: 限流器
- **Retry**: 重试
- **Bulkhead**: 隔离

### 5.3 熔断器 (Circuit Breaker)

#### 状态机机制：

1. **CLOSED (关闭)**: 正常状态，请求通过。如果失败率超过阈值，切换到 OPEN
2. **OPEN (打开)**: 熔断状态，请求快速失败（不调用远程服务）。经过等待时间后，切换到 HALF_OPEN
3. **HALF_OPEN (半开)**: 允许少量请求通过以测试服务是否恢复。如果成功，切回 CLOSED；如果失败，重回 OPEN

#### 降级 (Fallback) 实现：

通过实现 Feign 接口定义降级逻辑，当服务不可用时返回默认数据。

```java
@Component
public class UserClientFallback implements UserClient {
    @Override
    public User getUser(Long id) {
        return new User(id, "默认用户", "default@example.com"); // 返回兜底数据
    }
}
```

### 5.4 重试 (Retry)

配置最大重试次数、等待间隔及指数退避策略，用于处理暂时性的网络波动。

## 6. 最佳实践与总结

### 推荐做法 (Do's)

- 使用 OpenFeign 简化调用
- 结合 Nacos 等注册中心
- 设置合理的超时时间
- 实现有意义的业务降级（Fallback）
- 配置重试策略并监控容错指标

### 避免做法 (Don'ts)

- 硬编码服务地址（应使用服务名）
- 忽略超时设置（会导致级联故障）
- 降级简单返回 null（易引发空指针）
- 过度重试（可能加重下游负担）
- 循环依赖调用

### 实践任务建议

完成以下练习以巩固知识：

启动多个服务实例，验证 OpenFeign 的调用、LoadBalancer 的轮询效果，以及手动停止服务来测试熔断和降级机制。
