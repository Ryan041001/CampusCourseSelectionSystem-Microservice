# 课程选课系统微服务改造实战
**从单体架构到微服务拆分全过程**
2025-11-27

---

## 📚 本节内容
*   🔍 **单体应用剖析**：分析架构瓶颈
*   🔨 **微服务拆分**：设计原则与实操
*   🔌 **服务间通信**：实现
*   ⚠️ **数据一致性挑战**：四种策略对比
*   🐳 **Docker容器化部署**
*   🔄 **最佳实践总结**

---

## 🎯 学习目标
*   掌握**单体 vs 微服务**的架构区别
*   理解从单体到微服务的完整迁移过程
*   掌握微服务拆分的**设计原则**
*   处理微服务拆分后的**数据一致性**问题
*   使用 Docker Compose 编排微服务集群

---

## 项目背景：课程选课系统

**核心模块**
*   **课程管理** (课程代码、名称、学分限制)
*   **学生管理** (基础信息)
*   **选课管理** (核心业务)

**用户角色**
*   **学生**：浏览、选课
*   **教务员**：管理

**技术栈**
*   Spring Boot 3
*   Spring Data JPA
*   H2 Database (演示用) / MySQL
*   Docker & Docker Compose

---

## 单体架构：course v1.1.0

*(此处为单体架构图：Client -> Controller -> Service -> Repository -> Database)*

**特点：**
*   单一进程、统一端口 8080
*   模块间通过函数调用
*   共享同一个数据库连接
*   部署简单 (一个 JAR 包)

---

## ❌ 单体架构的问题

### ☠️ 业务增长面临的挑战
*   **耦合**：修改选课逻辑涉及全库，牵一发而动全身
*   **扩展**：选课高峰期只需要扩容“选课模块”，但必须扩容整个应用
*   **技术栈**：难以引入新技术
*   **容错**：一个模块内存溢出，全系统崩溃

### 👤 典型场景
*   **开发**：代码冲突频繁
*   **测试**：改了一行代码，要回归所有功能
*   **部署**：编译时间长，启动慢
*   **高并发**：数据库连接池竞争

---

## 微服务拆分策略

**按业务领域拆分 (三个微服务)**
1.  **user-service** (端口 8081)
    *   数据表：`user_db`
    *   职责：用户基础数据
2.  **catalog-service** (端口 8082)
    *   数据表：`catalog_db`
    *   职责：课程相关数据
3.  **enrollment-service** (端口 8083)
    *   数据表：`enrollment_db`
    *   职责：选课业务逻辑，依赖上述两个服务

**数据库拆分**
*   **原则**：一个服务一个数据库 (Database per Service)
*   **目的**：解耦数据层，防止跨库 Join

---

## 微服务架构：course-cloud v1.0.0

*(此处为微服务架构图：分为三个独立服务，各自连接独立数据库，通过 HTTP 交互)*

---

## 改造第一步：创建服务项目

**Maven 父子工程结构**
1.  创建一个父工程
2.  分别创建三个子模块
3.  提取公共依赖
4.  调整包名和配置

**步骤**
*   每个模块独立 `pom.xml`
*   每个模块独立 `Application`
*   添加 `docker-compose.yml` 编排
*   保留原单体代码作参考

---

## 改造第二步：拆分实体类

### 🎯 微服务实体类设计原则
**原则**
*   ❌ **不要共享 Entity**：不要把所有实体类放在一个 common jar 包里
*   ✅ **允许代码重复**：每个服务保留自己需要的字段（DTO/VO 模式）
*   ✅ **只保留必要字段**：例如选课服务只需要用户的 ID 和 Email
*   ✅ **最小化依赖**：服务间尽量减少代码层面的依赖
*   ✅ **统一数据类型**：跨服务的主键类型保持一致

---

### 改造第二步：拆分实体类 (1/3)
**🧱 user-service 实体类**

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String email;
    // 省略 getter/setter
}
```

### 改造第二步：拆分实体类 (2/3)
**📚 catalog-service 实体类**

```java
@Entity
@Table(name = "courses")
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private Integer credits;
    // 省略 getter/setter
}
```

### 改造第二步：拆分实体类 (3/3)
**📝 enrollment-service 实体类**

```java
@Entity
@Table(name = "enrollments")
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long userId;    // 仅存储ID，不关联User对象
    private Long courseId;  // 仅存储ID，不关联Course对象
    
    private LocalDateTime enrollmentDate;
    // 省略 getter/setter
}
```

---

## 改造第三步：独立数据库

**原单体数据库配置**
*   单一 `spring.datasource.url`

**微服务独立配置**
*   **User Service**: `jdbc:h2:mem:user_db`
*   **Catalog Service**: `jdbc:h2:mem:catalog_db`
*   **Enrollment Service**: `jdbc:h2:mem:enrollment_db`

*(图示展示了 application.yml 中不同的 datasource 配置及对应的 SQL 初始化脚本)*

---

## 改造第四步：服务间通信

**问题**：选课服务需要获取用户信息和课程信息（但不能直接查表）
**解决方案**：使用 `RestTemplate` 发起 HTTP 调用

**1. 配置 RestTemplate Bean**
```java
@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**2. 发起远程调用**
```java
// 在 EnrollmentService 中
UserDTO user = restTemplate.getForObject(
    "http://localhost:8081/users/" + userId, 
    UserDTO.class
);

CourseDTO course = restTemplate.getForObject(
    "http://localhost:8082/courses/" + courseId, 
    CourseDTO.class
);
```

---

## 依赖关系分析

**🔄 服务调用链路**
*   **调用方向**：
    *   Enrollment -> User (验证学生)
    *   Enrollment -> Catalog (验证课程)
*   **被调用方**：User, Catalog
*   **禁止循环依赖**：
    *   ❌ User -> Enrollment (不要这样做！)

---

## ⚠️ 问题：数据一致性挑战
**🔍 删除学生时的问题**

*   **单体应用**：
    *   **数据库外键约束** (Foreign Key) 自动阻止删除，或者级联删除。
    *   事务 ACID 保证原子性。
*   **微服务**：
    *   **跨库无外键**：`user_db` 不知道 `enrollment_db` 的存在。
    *   **结果**：删除了学生，但选课记录还留在选课库中，变成“孤儿数据”。

---

### 解决方案 1：拒绝删除策略
**🛑 逻辑检查后拦截**

**实现方式**：
User Service 在删除前，先调用 Enrollment Service 查询是否有选课记录。

```java
// User Service
public void deleteUser(Long id) {
    // 远程调用检查
    Boolean hasEnrollments = restTemplate.getForObject(
        "http://localhost:8083/enrollments/check/" + id, 
        Boolean.class
    );
    
    if (hasEnrollments) {
        throw new RuntimeException("该学生有选课记录，无法删除");
    }
    userRepository.deleteById(id);
}
```

**优缺点**：
*   ✅ 简单直观
*   ✅ 保持数据完整性
*   ❌ 增加了服务间耦合 (User 依赖 Enrollment)
*   ❌ 性能损耗 (HTTP请求)

---

### 解决方案 2：软删除策略 ⭐
**✅ 标记删除，不真删 (推荐)**

**实现方式**：
在 User 表添加 `deleted` 字段，删除时仅更新状态。

```java
@Entity
@SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ?")
@Where(clause = "deleted = false")
public class User {
    // ...
    private Boolean deleted = false;
}
```

**优缺点**：
*   ✅ **解耦**：User 服务不需要询问 Enrollment 服务
*   ✅ **安全**：数据可恢复 (后悔药)
*   ✅ **性能好**：无远程调用
*   ❌ 需要全表增加 `deleted` 字段
*   ❌ 查询时需过滤已删除数据 (Hibernate `@Where` 可自动处理)
*   ⭐ **大多数商业产品的首选方案**

---

### 解决方案 3：级联删除策略
**⚠️ 危险的关联删除**

**实现方式**：
User Service 删除用户后，同步调用 Enrollment Service 删除相关选课。

```java
// User Service
@Transactional
public void deleteUser(Long id) {
    userRepository.deleteById(id);
    // 远程调用删除
    restTemplate.delete("http://localhost:8083/enrollments/user/" + id);
}
```

**缺点**：
*   ❌ **无法保证原子性** (分布式事务问题)
    *   如果是本地删了，远程删除失败怎么办？
*   ❌ **危险**：误操作后果严重
*   ❌ **高耦合**

---

### 解决方案 4：事件驱动策略
**⚡ 异步消息通知**

**实现方式**：
User Service 删除用户 -> 发送消息 (MQ) -> Enrollment Service 监听消息并处理。

```java
// User Service
messageQueue.send("user-deleted-topic", userId);

// Enrollment Service
@JmsListener(destination = "user-deleted-topic")
public void handleUserDeleted(Long userId) {
    enrollmentRepository.deleteByUserId(userId);
}
```

**优缺点**：
*   ✅ **高解耦**
*   ✅ **最终一致性**
*   ❌ **复杂度高** (引入 MQ)
*   ❌ **异步延迟**

---

## 数据一致性策略对比

| 策略 | 复杂度 | 耦合度 | 一致性 | 推荐度 |
| :--- | :--- | :--- | :--- | :--- |
| **拒绝删除** | 低 | 高 | 强一致 | ⭐⭐ |
| **软删除** | 低 | 低 | 逻辑一致 | ⭐⭐⭐⭐⭐ |
| **级联删除** | 中 | 高 | 弱 (易失败) | ⭐ |
| **事件驱动** | 高 | 低 | 最终一致 | ⭐⭐⭐ |

---

## Docker 容器化部署

### 🐳 Docker Compose 配置

```yaml
version: '3.8'
services:
  user-service:
    build: ./user-service
    ports:
      - "8081:8081"
  catalog-service:
    build: ./catalog-service
    ports:
      - "8082:8082"
  enrollment-service:
    build: ./enrollment-service
    ports:
      - "8083:8083"
    depends_on:
      - user-service
      - catalog-service
```

### 🚀 一键启动脚本 (run.sh)

```bash
#!/bin/bash
# 1. Maven 构建
mvn clean package -DskipTests

# 2. Docker 构建与启动
docker-compose up --build -d

# 3. 查看日志
docker-compose logs -f
```

---

## 测试微服务
**🧪 完整流程测试**

使用 HTTP Client 文件 (`test.http`)：

1.  **添加用户** (POST :8081/users)
2.  **添加课程** (POST :8082/courses)
3.  **学生选课** (POST :8083/enrollments)
    *   *验证*：会远程调用 8081 和 8082 检查 ID 是否存在
4.  **查询选课** (GET :8083/enrollments)

---

## 改造成果总结

### ✅ 完成的工作
*   **服务拆分**：将单体拆分为三个独立服务
*   **数据库拆分**：每个服务拥有独立 DB (Database per Service)
*   **实体类解耦**：不再共享 Entity
*   **远程通信**：使用 RestTemplate
*   **Docker部署**：容器化编排 (docker-compose)

### ❌ 遗留问题
*   **硬编码 URL**：`localhost:8081` 写死在代码里
*   **无服务发现**：服务多了怎么管理？IP 变了怎么办？
*   **配置分散**：每个服务都有自己的 `application.yml`
*   **无熔断降级**：User 服务挂了，Enrollment 服务也会卡死

---

## 微服务带来的新挑战

**1. 地址维护困难**
*   **现状**：URL 硬编码
*   **问题**：服务扩容、IP 变动需修改代码
*   **解决**：服务注册与发现 (Service Discovery - Nacos/Eureka)

**2. 分布式事务**
*   **现状**：本地事务无法跨服务
*   **问题**：跨库数据一致性难保证
*   **解决**：Saga 模式、Seata、消息队列最终一致性

**3. 可观测性**
*   **现状**：日志分散在不同容器
*   **问题**：出了问题难以定位 (Trace ID 缺失)
*   **解决**：分布式链路追踪 (Zipkin/SkyWalking)

**4. 配置管理**
*   **现状**：配置散落在各项目
*   **解决**：配置中心 (Config Center)

---

## 最佳实践总结

### ✅ 推荐做法
*   **独立数据库 (Database per Service)**
*   **DTO 传输对象** (不暴露 Entity)
*   **服务间松耦合**
*   **自动化部署** (Docker/K8s)
*   **软删除** (逻辑删除)

### ❌ 避免做法
*   **共享数据库** (所有服务连一个库)
*   **共享代码库** (Entity/Service 打成公共 JAR)
*   **同步级联删除**
*   **循环依赖** (A->B->A)
*   **手动配置环境**

---

## 下一步优化方向
**📡 服务注册与发现**

**架构图解**：
1.  **Service Registry (Nacos)**: 注册中心
2.  **User Service**: 启动时注册 `user-service` -> `192.168.x.x:8081`
3.  **Enrollment Service**: 调用时询问注册中心 "user-service 在哪？"

**优势**：解耦 IP 地址，支持负载均衡。

---

## 实战练习
**🛠️ 本节实战任务**

1.  复制 course 单体应用源码
2.  完成三个微服务的拆分
3.  实现软删除 (Soft Delete)
4.  编写 Dockerfile
5.  使用 RestTemplate 完成通信
6.  使用 run.sh 一键运行

**进阶挑战**
*   尝试实现“拒绝删除”策略
*   修改端口号，验证配置是否生效
*   在 Docker 中查看各服务日志

---

## 参考资源
**📚 学习资料**
*   Spring Cloud 官方文档
*   Docker 官方文档
*   *Microservices Patterns* (Chris Richardson)
*   Martin Fowler - Microservices

**关键词**
*   Database per Service
*   Event Sourcing
*   CQRS
*   Spring Boot Reference
*   RestTemplate 文档

---

## 总结
**📌 本节重点回顾**

**核心概念**
*   **单体 vs 微服务**：耦合度与复杂度权衡
*   **数据库拆分**：数据主权
*   **远程调用**：RestTemplate HTTP
*   **独立部署设计**：Docker

**核心挑战**
*   **数据一致性问题**
*   **服务调用可靠性**
*   **部署运维复杂度**
*   **测试复杂度**

**代码技巧**
*   Rest Template 远程调用
*   Hibernate @Where 软删除
*   Docker 容器化过程

**心路历程**
*   拆分不仅是复制粘贴
*   要考虑“数据怎么查”
*   要考虑“关联数据怎么删”
*   架构设计是权衡的艺术

---

**Thanks!**